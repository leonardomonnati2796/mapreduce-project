# Makefile for AWS Deployment of MapReduce Project
# This file provides commands for deploying and managing the MapReduce system on AWS

# Default values
AWS_REGION ?= us-east-1
PROJECT_NAME ?= mapreduce
ENVIRONMENT ?= prod
INSTANCE_TYPE ?= t3.medium
MIN_INSTANCES ?= 2
MAX_INSTANCES ?= 10
DESIRED_INSTANCES ?= 3

# Directories
AWS_DIR = aws
TERRAFORM_DIR = $(AWS_DIR)/terraform
DOCKER_DIR = $(AWS_DIR)/docker
SCRIPTS_DIR = $(AWS_DIR)/scripts
CONFIG_DIR = $(AWS_DIR)/config

# Colors
RED = \033[0;31m
GREEN = \033[0;32m
YELLOW = \033[1;33m
BLUE = \033[0;34m
CYAN = \033[0;36m
NC = \033[0m # No Color

# Help target
.PHONY: help
help: ## Show this help message
	@echo "$(CYAN)AWS Deployment Makefile for MapReduce Project$(NC)"
	@echo ""
	@echo "$(YELLOW)Usage: make [target] [VARIABLE=value]$(NC)"
	@echo ""
	@echo "$(YELLOW)Variables:$(NC)"
	@echo "  AWS_REGION=region           AWS region (default: us-east-1)"
	@echo "  PROJECT_NAME=name           Project name (default: mapreduce)"
	@echo "  ENVIRONMENT=env             Environment (default: prod)"
	@echo "  INSTANCE_TYPE=type          EC2 instance type (default: t3.medium)"
	@echo "  MIN_INSTANCES=count         Minimum instances (default: 2)"
	@echo "  MAX_INSTANCES=count         Maximum instances (default: 10)"
	@echo "  DESIRED_INSTANCES=count     Desired instances (default: 3)"
	@echo ""
	@echo "$(YELLOW)Targets:$(NC)"
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?## / {printf "  $(GREEN)%-20s$(NC) %s\n", $$1, $$2}' $(MAKEFILE_LIST)

# Setup targets
.PHONY: aws-setup
aws-setup: ## Setup AWS environment
	@echo "$(BLUE)[INFO]$(NC) Setting up AWS environment..."
	@chmod +x $(SCRIPTS_DIR)/setup-aws-env.sh
	@$(SCRIPTS_DIR)/setup-aws-env.sh --region $(AWS_REGION) --project-name $(PROJECT_NAME) --environment $(ENVIRONMENT)

.PHONY: aws-setup-powershell
aws-setup-powershell: ## Setup AWS environment using PowerShell
	@echo "$(BLUE)[INFO]$(NC) Setting up AWS environment with PowerShell..."
	@powershell -ExecutionPolicy Bypass -File $(SCRIPTS_DIR)/setup-aws-env.ps1 -Region $(AWS_REGION) -ProjectName $(PROJECT_NAME) -Environment $(ENVIRONMENT)

# Terraform targets
.PHONY: terraform-init
terraform-init: ## Initialize Terraform
	@echo "$(BLUE)[INFO]$(NC) Initializing Terraform..."
	@cd $(TERRAFORM_DIR) && terraform init

.PHONY: terraform-plan
terraform-plan: ## Create Terraform plan
	@echo "$(BLUE)[INFO]$(NC) Creating Terraform plan..."
	@cd $(TERRAFORM_DIR) && terraform plan -out=tfplan

.PHONY: terraform-apply
terraform-apply: ## Apply Terraform configuration
	@echo "$(BLUE)[INFO]$(NC) Applying Terraform configuration..."
	@cd $(TERRAFORM_DIR) && terraform apply -auto-approve tfplan

.PHONY: terraform-destroy
terraform-destroy: ## Destroy Terraform infrastructure
	@echo "$(BLUE)[INFO]$(NC) Destroying Terraform infrastructure..."
	@cd $(TERRAFORM_DIR) && terraform destroy -auto-approve

.PHONY: terraform-output
terraform-output: ## Show Terraform outputs
	@echo "$(BLUE)[INFO]$(NC) Showing Terraform outputs..."
	@cd $(TERRAFORM_DIR) && terraform output

.PHONY: terraform-validate
terraform-validate: ## Validate Terraform configuration
	@echo "$(BLUE)[INFO]$(NC) Validating Terraform configuration..."
	@cd $(TERRAFORM_DIR) && terraform validate

# Docker targets
.PHONY: docker-build
docker-build: ## Build Docker images
	@echo "$(BLUE)[INFO]$(NC) Building Docker images..."
	@docker build -f $(DOCKER_DIR)/Dockerfile.aws -t mapreduce-master:latest --build-arg BUILD_TARGET=master .
	@docker build -f $(DOCKER_DIR)/Dockerfile.aws -t mapreduce-worker:latest --build-arg BUILD_TARGET=worker .
	@docker build -f $(DOCKER_DIR)/Dockerfile.aws -t mapreduce-backup:latest --build-arg BUILD_TARGET=backup .

.PHONY: docker-test
docker-test: ## Test Docker images
	@echo "$(BLUE)[INFO]$(NC) Testing Docker images..."
	@docker run --rm mapreduce-master:latest --version
	@docker run --rm mapreduce-worker:latest --version

.PHONY: docker-push
docker-push: ## Push Docker images to registry
	@echo "$(BLUE)[INFO]$(NC) Pushing Docker images to registry..."
	@docker tag mapreduce-master:latest $(DOCKER_REGISTRY)/mapreduce-master:latest
	@docker tag mapreduce-worker:latest $(DOCKER_REGISTRY)/mapreduce-worker:latest
	@docker tag mapreduce-backup:latest $(DOCKER_REGISTRY)/mapreduce-backup:latest
	@docker push $(DOCKER_REGISTRY)/mapreduce-master:latest
	@docker push $(DOCKER_REGISTRY)/mapreduce-worker:latest
	@docker push $(DOCKER_REGISTRY)/mapreduce-backup:latest

# Deployment targets
.PHONY: aws-deploy
aws-deploy: ## Deploy to AWS
	@echo "$(BLUE)[INFO]$(NC) Deploying to AWS..."
	@chmod +x $(SCRIPTS_DIR)/deploy-aws.sh
	@$(SCRIPTS_DIR)/deploy-aws.sh --region $(AWS_REGION) --project-name $(PROJECT_NAME) --environment $(ENVIRONMENT) --instance-type $(INSTANCE_TYPE) --min-instances $(MIN_INSTANCES) --max-instances $(MAX_INSTANCES) --desired-instances $(DESIRED_INSTANCES)

.PHONY: aws-deploy-powershell
aws-deploy-powershell: ## Deploy to AWS using PowerShell
	@echo "$(BLUE)[INFO]$(NC) Deploying to AWS with PowerShell..."
	@powershell -ExecutionPolicy Bypass -File $(SCRIPTS_DIR)/deploy-aws.ps1 -Region $(AWS_REGION) -ProjectName $(PROJECT_NAME) -Environment $(ENVIRONMENT) -InstanceType $(INSTANCE_TYPE) -MinInstances $(MIN_INSTANCES) -MaxInstances $(MAX_INSTANCES) -DesiredInstances $(DESIRED_INSTANCES)

.PHONY: aws-deploy-quick
aws-deploy-quick: ## Quick deploy to AWS (skip some steps)
	@echo "$(BLUE)[INFO]$(NC) Quick deploying to AWS..."
	@chmod +x $(SCRIPTS_DIR)/deploy-aws.sh
	@$(SCRIPTS_DIR)/deploy-aws.sh --region $(AWS_REGION) --project-name $(PROJECT_NAME) --environment $(ENVIRONMENT) --instance-type $(INSTANCE_TYPE) --min-instances $(MIN_INSTANCES) --max-instances $(MAX_INSTANCES) --desired-instances $(DESIRED_INSTANCES) --skip-docker --skip-monitoring --skip-backup

# Status and monitoring targets
.PHONY: aws-status
aws-status: ## Show AWS deployment status
	@echo "$(BLUE)[INFO]$(NC) Showing AWS deployment status..."
	@cd $(TERRAFORM_DIR) && terraform output
	@echo ""
	@echo "$(CYAN)=== LOAD BALANCER STATUS ===$(NC)"
	@aws elbv2 describe-load-balancers --region $(AWS_REGION) --query 'LoadBalancers[?contains(LoadBalancerName, \'$(PROJECT_NAME)\')].{Name:LoadBalancerName,DNSName:DNSName,State:State.Code}' --output table
	@echo ""
	@echo "$(CYAN)=== AUTO SCALING GROUPS ===$(NC)"
	@aws autoscaling describe-auto-scaling-groups --region $(AWS_REGION) --query 'AutoScalingGroups[?contains(AutoScalingGroupName, \'$(PROJECT_NAME)\')].{Name:AutoScalingGroupName,DesiredCapacity:DesiredCapacity,MinSize:MinSize,MaxSize:MaxSize,Instances:length(Instances)}' --output table

.PHONY: aws-logs
aws-logs: ## Show AWS logs
	@echo "$(BLUE)[INFO]$(NC) Showing AWS logs..."
	@echo "$(CYAN)=== CLOUDWATCH LOG GROUPS ===$(NC)"
	@aws logs describe-log-groups --region $(AWS_REGION) --log-group-name-prefix "/aws/ec2/$(PROJECT_NAME)" --query 'logGroups[].{Name:logGroupName,Retention:retentionInDays}' --output table
	@echo ""
	@echo "$(CYAN)=== RECENT LOG EVENTS ===$(NC)"
	@aws logs describe-log-streams --region $(AWS_REGION) --log-group-name "/aws/ec2/$(PROJECT_NAME)/master" --order-by LastEventTime --descending --max-items 5 --query 'logStreams[].{StreamName:logStreamName,LastEventTime:lastEventTime}' --output table

.PHONY: aws-metrics
aws-metrics: ## Show AWS metrics
	@echo "$(BLUE)[INFO]$(NC) Showing AWS metrics..."
	@echo "$(CYAN)=== CLOUDWATCH METRICS ===$(NC)"
	@aws cloudwatch list-metrics --region $(AWS_REGION) --namespace "AWS/EC2" --query 'Metrics[?contains(MetricName, \'CPUUtilization\')].{MetricName:MetricName,Namespace:Namespace}' --output table

# S3 targets
.PHONY: aws-s3-status
aws-s3-status: ## Show S3 bucket status
	@echo "$(BLUE)[INFO]$(NC) Showing S3 bucket status..."
	@echo "$(CYAN)=== S3 BUCKETS ===$(NC)"
	@aws s3 ls --region $(AWS_REGION) | grep $(PROJECT_NAME)
	@echo ""
	@echo "$(CYAN)=== S3 BUCKET CONTENTS ===$(NC)"
	@aws s3 ls s3://$(PROJECT_NAME)-storage-$(shell aws sts get-caller-identity --query Account --output text) --region $(AWS_REGION) || echo "Storage bucket not found"
	@aws s3 ls s3://$(PROJECT_NAME)-backup-$(shell aws sts get-caller-identity --query Account --output text) --region $(AWS_REGION) || echo "Backup bucket not found"

.PHONY: aws-s3-backup
aws-s3-backup: ## Create S3 backup
	@echo "$(BLUE)[INFO]$(NC) Creating S3 backup..."
	@aws s3 sync s3://$(PROJECT_NAME)-storage-$(shell aws sts get-caller-identity --query Account --output text) s3://$(PROJECT_NAME)-backup-$(shell aws sts get-caller-identity --query Account --output text)/backup/$(shell date +%Y%m%d_%H%M%S) --region $(AWS_REGION)

# Cleanup targets
.PHONY: aws-cleanup
aws-cleanup: ## Cleanup AWS resources
	@echo "$(BLUE)[INFO]$(NC) Cleaning up AWS resources..."
	@cd $(TERRAFORM_DIR) && terraform destroy -auto-approve

.PHONY: aws-cleanup-s3
aws-cleanup-s3: ## Cleanup S3 buckets
	@echo "$(BLUE)[INFO]$(NC) Cleaning up S3 buckets..."
	@aws s3 rb s3://$(PROJECT_NAME)-storage-$(shell aws sts get-caller-identity --query Account --output text) --force --region $(AWS_REGION) || true
	@aws s3 rb s3://$(PROJECT_NAME)-backup-$(shell aws sts get-caller-identity --query Account --output text) --force --region $(AWS_REGION) || true

# Test targets
.PHONY: aws-test
aws-test: ## Test AWS deployment
	@echo "$(BLUE)[INFO]$(NC) Testing AWS deployment..."
	@cd $(TERRAFORM_DIR) && LB_DNS=$$(terraform output -raw load_balancer_dns_name) && \
		echo "Testing health endpoint: http://$$LB_DNS/health" && \
		curl -f -s --max-time 30 "http://$$LB_DNS/health" && \
		echo "Testing dashboard endpoint: http://$$LB_DNS/dashboard" && \
		curl -f -s --max-time 30 "http://$$LB_DNS/dashboard" || echo "Dashboard test failed"

.PHONY: aws-test-load
aws-test-load: ## Run load test on AWS deployment
	@echo "$(BLUE)[INFO]$(NC) Running load test on AWS deployment..."
	@cd $(TERRAFORM_DIR) && LB_DNS=$$(terraform output -raw load_balancer_dns_name) && \
		echo "Running load test on: http://$$LB_DNS" && \
		ab -n 1000 -c 10 "http://$$LB_DNS/health" || echo "Load test failed"

# Configuration targets
.PHONY: aws-config
aws-config: ## Show AWS configuration
	@echo "$(BLUE)[INFO]$(NC) Showing AWS configuration..."
	@echo "$(CYAN)=== AWS CONFIGURATION ===$(NC)"
	@echo "Region: $(AWS_REGION)"
	@echo "Project: $(PROJECT_NAME)"
	@echo "Environment: $(ENVIRONMENT)"
	@echo "Instance Type: $(INSTANCE_TYPE)"
	@echo "Instances: $(MIN_INSTANCES)-$(MAX_INSTANCES) (desired: $(DESIRED_INSTANCES))"
	@echo ""
	@echo "$(CYAN)=== AWS CREDENTIALS ===$(NC)"
	@aws sts get-caller-identity --query '{Account:Account,User:Arn,Region:$(AWS_REGION)}' --output table

.PHONY: aws-config-validate
aws-config-validate: ## Validate AWS configuration
	@echo "$(BLUE)[INFO]$(NC) Validating AWS configuration..."
	@aws sts get-caller-identity > /dev/null && echo "$(GREEN)✓$(NC) AWS credentials valid" || echo "$(RED)✗$(NC) AWS credentials invalid"
	@aws s3 ls > /dev/null && echo "$(GREEN)✓$(NC) S3 access valid" || echo "$(RED)✗$(NC) S3 access invalid"
	@aws ec2 describe-regions --region-names $(AWS_REGION) > /dev/null && echo "$(GREEN)✓$(NC) Region $(AWS_REGION) valid" || echo "$(RED)✗$(NC) Region $(AWS_REGION) invalid"

# All-in-one targets
.PHONY: aws-full-deploy
aws-full-deploy: aws-setup terraform-init terraform-plan terraform-apply docker-build aws-deploy aws-test ## Full AWS deployment

.PHONY: aws-quick-deploy
aws-quick-deploy: terraform-init terraform-apply aws-deploy-quick aws-test ## Quick AWS deployment

.PHONY: aws-full-cleanup
aws-full-cleanup: aws-cleanup aws-cleanup-s3 ## Full AWS cleanup

# Default target
.DEFAULT_GOAL := help